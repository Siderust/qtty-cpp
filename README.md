# qtty-cpp: Type-Safe Physical Quantities for C++

A modern C++17 header-only library providing compile-time type-safe physical quantities with automatic unit conversions, powered by the high-performance Rust [qtty](https://github.com/sidereal-dave/qtty) library through qtty-ffi.

[![C++17](https://img.shields.io/badge/C%2B%2B-17-blue.svg)](https://en.cppreference.com/w/cpp/17)
[![CMake](https://img.shields.io/badge/CMake-3.15%2B-064F8C.svg)](https://cmake.org/)
[![License](https://img.shields.io/badge/License-See%20qtty-green.svg)](qtty/LICENSE)

## Features

- âœ¨ **Type-safe**: Compile-time unit checking prevents dimension errors
- ğŸ¯ **Ergonomic**: Natural operator syntax with user-defined literals
- ğŸš€ **Zero-overhead**: Header-only template design with inline functions
- ğŸ¨ **Modern C++17**: Leverages constexpr, template metaprogramming, and CTAD
- ğŸ›¡ï¸ **Exception-based errors**: Clear exception hierarchy for runtime errors
- ğŸ”§ **Auto-generated**: C++ bindings automatically generated from Rust FFI
- ğŸ“¦ **Easy integration**: Single header include with CMake export
- âœ… **Comprehensively tested**: 37+ Google Test cases covering all operations

#### Docker

```bash
# Build the docker image
docker build -t qtty-cpp-dev .

# Run and atach to the container
docker run -it qtty-cpp-dev
```

## Quick Start

```cpp
#include "qtty/qtty.hpp"
using namespace qtty;

int main() {
    // Create quantities using constructors or literals
    auto distance = 100.0_km;
    auto time = 2.0_h;
    
    // Perform type-safe arithmetic
    auto speed = distance / time;  // Type: KilometerPerHour
    std::cout << speed.value() << " km/h\n";  // Prints: 50 km/h
    
    // Convert units safely
    Meter m = distance.to<Meter>();
    std::cout << m.value() << " m\n";  // Prints: 100000 m
    
    // Compile-time safety prevents errors
    // distance + time;  // Compile error: incompatible types
    
    return 0;
}
```

### Installation

```bash
# Clone with submodules
git clone --recurse-submodules https://github.com/your-repo/qtty-cpp.git
cd qtty-cpp

# Build and test
mkdir build && cd build
cmake ..
make -j$(nproc)
ctest --output-on-failure

# Run demo
./demo
```

See [Build and Testing Guide](docs/build-and-testing.md) for detailed instructions, dependencies, and troubleshooting.

## Architecture Overview

qtty-cpp is built on a three-layer architecture:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     C++ Template Layer (qtty-cpp)           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Quantity<UnitTag> template             â”‚ â”‚
â”‚  â”‚ - Type safety, operators, literals     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    Generated C++ Headers                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Tag structs, UnitTraits, type aliases  â”‚ â”‚
â”‚  â”‚ Auto-generated by gen_cpp_units.py     â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Rust qtty-ffi Library                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ Unit conversions, C FFI interface      â”‚ â”‚
â”‚  â”‚ High-performance Rust implementation   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Components**:

1. **[Rust qtty-ffi](qtty/qtty-ffi/)** - Core conversion engine (C FFI)
2. **[Python Generator](gen_cpp_units.py)** - Parses FFI header, generates C++ wrappers
3. **[C++ Templates](include/qtty/ffi_core.hpp)** - Type-safe `Quantity<>` class with operators
4. **[CMake Build](CMakeLists.txt)** - Orchestrates Cargo, Python, and C++ compilation

See [Architecture Documentation](docs/architecture.md) for detailed design explanation.

## Usage Examples

### Basic Operations

```cpp
#include "qtty/qtty.hpp"
using namespace qtty;

int main() {
    // Create quantities using constructors
    Meter distance(1000.0);
    Second time(20.0);
    
    // Or use user-defined literals
    auto height = 5.5_m;
    auto duration = 10.0_s;
    
    // Perform arithmetic operations
    auto total_distance = distance + height;
    auto doubled = distance * 2.0;
    
    // Unit conversions are type-safe
    Kilometer km = distance.to<Kilometer>();
    std::cout << "Distance: " << km.value() << " km\n";
    
    // Create compound units (velocity)
    auto velocity = distance / time;
    std::cout << "Velocity: " << velocity.value() << " m/s\n";
    
    // Comparisons work naturally
    if (distance > height) {
        std::cout << "Distance is greater\n";
    }
    
    // Use compound assignment operators
    distance += 100.0_m;
    distance *= 2.0;
    
    // Absolute value and negation
    Meter negative(-5.0);
    auto positive = negative.abs();
    
    return 0;
}
```

}
```

More examples in [examples/demo.cpp](examples/demo.cpp).

## Supported Units

qtty-cpp supports a comprehensive set of units across five dimensions. All units are automatically generated from the qtty-ffi library.

### Summary Matrix

| Dimension | Base Unit | Unit Count | Example Units | Literal Examples |
|-----------|-----------|------------|---------------|------------------|
| **Length** | Meter | 57 | Meter, Kilometer, Mile, LightYear | `10.0_m`, `5.0_km`, `1.0_ly` |
| **Time** | Second | 24 | Second, Minute, Hour, Day | `30.0_s`, `5.0_min`, `2.0_h` |
| **Angular** | Radian | 8 | Radian, Degree, Arcminute | `3.14_rad`, `90.0_deg` |
| **Mass** | Kilogram | 30 | Kilogram, Gram, Pound | `10.0_kg`, `1000.0_g`, `2.2_lb` |
| **Power** | Watt | 15 | Watt, Kilowatt, Horsepower | `100.0_W`, `5.0_kW`, `1.0_hp` |
| **Compound** | - | âˆ | Velocity (Length/Time) | Created by division |

### Length Units

**Metric**: PlanckLength, Yoctometer, Zeptometer, Attometer, Femtometer, Picometer, Nanometer, Micrometer, Millimeter, Centimeter, Decimeter, Meter, Decameter, Hectometer, Kilometer, Megameter, Gigameter, Terameter, Petameter, Exameter, Zettameter, Yottameter

**Physics**: BohrRadius, ClassicalElectronRadius, ElectronReducedComptonWavelength

**Astronomical**: AstronomicalUnit, LightYear, Parsec, Kiloparsec, Megaparsec, Gigaparsec, NominalLunarRadius, NominalLunarDistance, NominalEarthPolarRadius, NominalEarthRadius, NominalEarthEquatorialRadius, EarthMeridionalCircumference, EarthEquatorialCircumference, NominalJupiterRadius, NominalSolarRadius, NominalSolarDiameter

**Imperial/US**: Inch, Foot, Yard, Mile, Link, Fathom, Rod, Chain, NauticalMile

### Time Units

**Metric**: Yoctosecond, Zeptosecond, Attosecond, Femtosecond, Picosecond, Nanosecond, Microsecond, Millisecond, Second, Minute, Hour, Day, Week, Fortnight, Month, Year, Decade, Century, Millennium

**Physics**: PlanckTime, JiffyPhysics

**Astronomical**: SiderealDay, SiderealYear, TropicalYear

### Angular Units

Radian, Degree, Gradian, Turn, Arcminute, Arcsecond, MilliArcSecond, MicroArcSecond

### Mass Units

**Metric**: PlanckMass, Yoctogram, Zeptogram, Attogram, Femtogram, Picogram, Nanogram, Microgram, Milligram, Gram, Kilogram, Tonne, Kilotonne, Megatonne, Gigatonne

**Physics**: AtomicMassUnit, ElectronMass

**Astronomical**: NominalEarthMass, NominalJupiterMass, NominalSolarMass

**Imperial/US**: Grain, Dram, Ounce, Pound, Stone, Quarter, Hundredweight, Ton

### Power Units

**Metric**: Microwatt, Milliwatt, Watt, Kilowatt, Megawatt, Gigawatt, Terawatt, Petawatt

**Other**: Horsepower, MetricHorsepower, ElectricalHorsepower, MechanicalHorsepower, BoilerHorsepower, BTUPerHour, CaloriePerSecond

### Compound Units (Velocity)

Velocity units are created by dividing length by time:

```cpp
Meter distance(100.0);
Second time(20.0);
auto velocity = distance / time;  // Type: MeterPerSecond
```

**Common Velocity Type Aliases**:
- `MeterPerSecond` = `Quantity<CompoundTag<MeterTag, SecondTag>>`
- `KilometerPerHour` = `Quantity<CompoundTag<KilometerTag, HourTag>>`

**Note**: Compound units cannot be converted through the FFI layer. To convert velocity units, convert components separately:

```cpp
// m/s to km/h
MeterPerSecond mps(10.0);
Kilometer km(mps.value() / 1000.0);  // Convert numerator
Hour h(1.0 / 3600.0);                // Convert denominator
KilometerPerHour kph(km.value() / h.value());
```

See [Architecture docs](docs/architecture.md#compound-units-and-velocity) for compound unit details.

See [Architecture docs](docs/architecture.md#compound-units-and-velocity) for compound unit details.

## API Reference

### Core Template Class

## API Reference

### Core Template Class

#### `Quantity<UnitTag>`

Generic template for all physical quantities. Parameterized by a unit tag (e.g., `MeterTag`, `SecondTag`).

**Location**: [include/qtty/ffi_core.hpp](include/qtty/ffi_core.hpp)

**Key Members**:

| Member | Description |
|--------|-------------|
| `Quantity(double)` | Construct from value |
| `double value() const` | Get raw numeric value |
| `to<Target>()` | Convert to another unit |
| `abs()` | Absolute value |
| `+`, `-` | Same-unit arithmetic |
| `*`, `/` (scalar) | Scalar operations |
| `==`, `!=`, `<`, `>`, `<=`, `>=` | Comparisons |
| `+=`, `-=`, `*=`, `/=` | Compound assignment |
| Unary `-` | Negation |

**Type Aliases**: Every unit has a convenient alias: `using Meter = Quantity<MeterTag>;`

### User-Defined Literals

All literals are in the `qtty::literals` inline namespace (imported by `using namespace qtty`):

**Length**:
```cpp
**Length**:
```cpp
10.0_m      // Meter
5.0_km      // Kilometer
100.0_mm    // Millimeter
50.0_cm     // Centimeter
12.0_in     // Inch
3.0_ft      // Foot
1.0_mi      // Mile
1.0_au      // Astronomical Unit
1.0_ly      // Light Year
```

**Time**:
```cpp
30.0_s      // Second
5.0_min     // Minute
2.0_h       // Hour
1.0_day     // Day
100.0_ms    // Millisecond
500.0_us    // Microsecond
```

**Angular**:
```cpp
3.14159_rad // Radian
90.0_deg    // Degree
60.0_arcmin // Arcminute
3600.0_arcsec // Arcsecond
```

**Mass**:
```cpp
10.0_kg     // Kilogram
1000.0_g    // Gram
5000.0_mg   // Milligram
1.0_ton     // Metric Ton
2.2_lb      // Pound
```

**Power**:
```cpp
100.0_W     // Watt
5.0_kW      // Kilowatt
1.0_MW      // Megawatt
1.0_hp      // Horsepower
```

See [Quantity API Reference](docs/api/quantities.md) for complete documentation.

### Exception Hierarchy

```cpp
std::runtime_error
  â””â”€ QttyException
      â”œâ”€ InvalidUnitError            // Unknown unit ID
      â”œâ”€ IncompatibleDimensionsError // E.g., converting length to time
      â””â”€ ConversionError             // Invalid numeric value
```

**Example**:
```cpp
try {
    Meter m(100.0);
    Second s = m.to<Second>();  // Throws IncompatibleDimensionsError
} catch (const IncompatibleDimensionsError& e) {
    std::cerr << "Cannot convert: " << e.what() << '\n';
}
```

## Build Pipeline

The build orchestrates three tools: Python â†’ Cargo â†’ CMake.

### Build Stages

1. **Header Generation** (Python)
   - `gen_cpp_units.py` parses `qtty/qtty-ffi/include/qtty_ffi.h`
   - Generates `include/qtty/units/*.hpp` and `include/qtty/literals.hpp`

2. **Rust Library Compilation** (Cargo)
   - Builds `qtty-ffi` crate: `cargo build -p qtty-ffi --release`
   - Produces `libqtty_ffi.{so,dylib,dll}` in `qtty/target/release/`

3. **C++ Integration** (CMake)
   - Creates `qtty_cpp` INTERFACE library
   - Links executables against Rust shared library
   - Sets RPATH for runtime library location

### Dependencies

| Tool | Version | Purpose |
|------|---------|---------|
| CMake | 3.15+ | Build orchestration |
| C++ Compiler | C++17 | GCC 7+, Clang 5+, MSVC 2017+ |
| Python 3 | 3.6+ | Code generation |
| Cargo/Rust | Latest stable | qtty-ffi compilation |
| Google Test | v1.14.0 | Fetched automatically by CMake |

**Platform Support**: Linux, macOS, Windows (MSVC)

See [Build and Testing Guide](docs/build-and-testing.md) for detailed instructions.

## Testing

### Test Suite Overview

37+ Google Test cases across 9 test suites:

| Test Suite | File | Coverage |
|------------|------|----------|
| `LengthDimensionTest` | [test_length.cpp](tests/test_length.cpp) | Length conversions, arithmetic, edge cases |
| `TimeDimensionTest` | [test_time.cpp](tests/test_time.cpp) | Time unit operations |
| `AngularDimensionTest` | [test_angular.cpp](tests/test_angular.cpp) | Angular conversions |
| `MassDimensionTest` | [test_mass.cpp](tests/test_mass.cpp) | Mass unit operations |
| `PowerDimensionTest` | [test_power.cpp](tests/test_power.cpp) | Power unit operations |
| `DerivedQuantityTest` | [test_derived.cpp](tests/test_derived.cpp) | Velocity creation |
| `QuantityOperationsTest` | [test_operations.cpp](tests/test_operations.cpp) | All operators, utilities |
| `DimensionSafetyTest` | [test_dimension_safety.cpp](tests/test_dimension_safety.cpp) | Exception handling |
| `PrecisionEdgeCaseTest` | [test_precision.cpp](tests/test_precision.cpp) | Numerical edge cases |

### Running Tests

```bash
cd build

# Run all tests
ctest --output-on-failure

# Run specific test suite
./test_ffi --gtest_filter=LengthDimensionTest.*

# Run specific test
./test_ffi --gtest_filter=LengthDimensionTest.MeterConstruction

# List all tests
./test_ffi --gtest_list_tests
```

See [Build and Testing Guide](docs/build-and-testing.md#testing-strategy) for comprehensive testing documentation.

## Project Structure

```
qtty-cpp/
â”œâ”€â”€ CMakeLists.txt              # Build configuration
â”œâ”€â”€ gen_cpp_units.py            # C++ wrapper generator
â”œâ”€â”€ README.md                   # This file
â”œâ”€â”€ LICENSE                     # License file
â”‚
â”œâ”€â”€ include/qtty/               # C++ headers (mostly auto-generated)
â”‚   â”œâ”€â”€ qtty.hpp                # Main entry point
â”‚   â”œâ”€â”€ ffi_core.hpp            # Quantity<> template
â”‚   â”œâ”€â”€ literals.hpp            # User-defined literals (generated)
â”‚   â””â”€â”€ units/                  # Unit-specific headers (generated)
â”‚       â”œâ”€â”€ length.hpp          # Length units
â”‚       â”œâ”€â”€ time.hpp            # Time units
â”‚       â”œâ”€â”€ angular.hpp         # Angular units
â”‚       â”œâ”€â”€ mass.hpp            # Mass units
â”‚       â”œâ”€â”€ power.hpp           # Power units
â”‚       â””â”€â”€ velocity.hpp        # Compound velocity units
â”‚
â”œâ”€â”€ examples/
â”‚   â””â”€â”€ demo.cpp                # Usage demonstrations
â”‚
â”œâ”€â”€ tests/                      # Google Test suite
â”‚   â”œâ”€â”€ fixtures.hpp            # Test fixtures
â”‚   â”œâ”€â”€ main.cpp                # Test entry point
â”‚   â”œâ”€â”€ test_length.cpp         # Length unit tests
â”‚   â”œâ”€â”€ test_time.cpp           # Time unit tests
â”‚   â”œâ”€â”€ test_angular.cpp        # Angular unit tests
â”‚   â”œâ”€â”€ test_mass.cpp           # Mass unit tests
â”‚   â”œâ”€â”€ test_power.cpp          # Power unit tests
â”‚   â”œâ”€â”€ test_derived.cpp        # Compound unit tests
â”‚   â”œâ”€â”€ test_operations.cpp     # Operator tests
â”‚   â”œâ”€â”€ test_dimension_safety.cpp  # Exception tests
â”‚   â””â”€â”€ test_precision.cpp      # Edge case tests
â”‚
â”œâ”€â”€ docs/                       # Documentation
â”‚   â”œâ”€â”€ architecture.md         # Architecture deep-dive
â”‚   â”œâ”€â”€ build-and-testing.md    # Build/test guide
â”‚   â”œâ”€â”€ extending-units.md      # Adding new units
â”‚   â””â”€â”€ api/
â”‚       â””â”€â”€ quantities.md       # API reference
â”‚
â”œâ”€â”€ qtty/                       # Git submodule (Rust qtty library)
â”‚   â””â”€â”€ qtty-ffi/               # C FFI crate
â”‚       â”œâ”€â”€ include/
â”‚       â”‚   â””â”€â”€ qtty_ffi.h      # C header (generated by Rust)
â”‚       â””â”€â”€ target/release/
â”‚           â””â”€â”€ libqtty_ffi.*   # Compiled shared library
â”‚
â””â”€â”€ build/                      # Build artifacts (created by CMake)
    â”œâ”€â”€ demo                    # Demo executable
    â”œâ”€â”€ test_ffi                # Test executable
    â””â”€â”€ _deps/                  # Google Test (fetched by CMake)
```

## Integration with Your Project

### Method 1: CMake Subdirectory (Recommended)

```cmake
# In your CMakeLists.txt
add_subdirectory(path/to/qtty-cpp)
target_link_libraries(your_target PRIVATE qtty_cpp)
```

The `qtty_cpp` target automatically provides:
- Include directories for C++ and C FFI headers
- Link dependencies on the Rust shared library
- Proper RPATH configuration

### Method 2: CMake Install

```bash
cd qtty-cpp/build
sudo cmake --install .
```

Then in your project:

```cmake
find_package(qtty_cpp REQUIRED)
target_link_libraries(your_target PRIVATE qtty_cpp)
```

### Method 3: Manual Integration

```bash
g++ -std=c++17 \
    -I/path/to/qtty-cpp/include \
    -I/path/to/qtty-cpp/qtty/qtty-ffi/include \
    -L/path/to/qtty-cpp/qtty/target/release \
    -lqtty_ffi \
    -Wl,-rpath,/path/to/qtty-cpp/qtty/target/release \
    mycode.cpp -o myapp
```

## Documentation

- **[Architecture](docs/architecture.md)** - Design, layering, data flow, code generation
- **[API Reference](docs/api/quantities.md)** - Complete `Quantity<>` API, exceptions, literals
- **[Build & Testing](docs/build-and-testing.md)** - Setup, troubleshooting, test strategy
- **[Extending Units](docs/extending-units.md)** - Adding new units step-by-step

## Design Principles

1. **Type Safety First**: Incompatible operations caught at compile-time
2. **Zero-Cost Abstraction**: Templates resolved at compile-time
3. **Natural Syntax**: C++ operators work intuitively
4. **Automatic Generation**: Minimize manual maintenance
5. **Comprehensive Testing**: Every operation thoroughly tested

## Requirements

- **C++17 or later** (constexpr, template features)
- **CMake 3.15+** (FetchContent support)
- **Python 3.6+** (code generator)
- **Cargo/Rust** (latest stable recommended)
- **Modern compiler**: GCC 7+, Clang 5+, MSVC 2017+

## Contributing

When adding new units:

1. Modify Rust qtty-ffi source to define the unit
2. Rebuild qtty-ffi: `cargo build -p qtty-ffi --release`
3. Regenerate C++ headers: `python3 gen_cpp_units.py`
4. Add tests in `tests/test_*.cpp`
5. Update documentation

See [Extending Units Guide](docs/extending-units.md) for detailed instructions.

## License

See the [LICENSE](qtty/LICENSE) file in the qtty submodule for details.

## Acknowledgments

Built on top of the excellent [qtty](https://github.com/sidereal-dave/qtty) Rust library, providing a modern C++ interface with compile-time type safety.

## Version

- **qtty-cpp**: v0.1.0
- **FFI ABI**: Query at runtime with `qtty::abi_version()`

---

**Need Help?**

- Check [troubleshooting](docs/build-and-testing.md#troubleshooting) for common issues
- Review [examples/demo.cpp](examples/demo.cpp) for usage patterns
- See [test files](tests/) for comprehensive examples

